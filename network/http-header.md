# HTTP 구조

## header

* `<field-name>:<filed-value>` 형식
* HTTP 전송에 필요한 모든 부가정보를 담기 위해 사용한다.
  * 메세지 바디의 내용, 메세지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리 정보
* 표준 헤더가 너무 많음
* 필요 시 임의의 헤더 추가 가능
  
## 표현 헤더

  * 표현 데이터의 형식, 압축 방식, 자연 언어, 길이 등을 설명하는 헤더
  * Content-Type : 표현 데이터의 형식
    * Text/html; charset=utf-8
    * application/json
    * Image/png
  * Content-Encoding : 표현 데이터의 압축 방식
    * 표현 데이터를 압축하기 위해 사용
    * 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
    * 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제
    * gzip, deflate, identity
  * Content-Language : 표현 데이터의 자연 언어
    * ko, en, en-US
  * Content-Length : 표현 데이터의 길이
    * 바이트 단위
    * Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안된다.
      * Transfer-Encoding을 사용하는 경우 chunked의 방식으로 사용한다.
      * 많은 양의 데이터를 분할하여 보내기 때문에 전체 데이터의 크기를 알 수 없어 Content-Length 헤더와 사용할 수 없다.
  * request, response 둘 다 사용한다.

## 요청 헤더

* From
  * 유저 에이전트의 이메일 정보
  * 일반적으로 잘 사용하지 않는다.
  * 검색 엔진에서 주로 사용한다.
  * 요청에서 사용한다.
* Referer
  * 이전 웹 페이지 주소
  * 현재 요청된 페이지의 이전 웹 페이지 주소
  * A → B로 이동하는 경우 B를 요청할 때 Referer: A 를 포함해서 요청한다.
  * Referer 를 사용하면 유입경로 수집 가능하다.
  * 요청에서 사용한다.
  * referer는 단어 referrer의 오탈자이지만 스펙으로 굳어졌다.
* USer-Agent
  * 유저 에이전트 애플리케이션 정보
  * 클라이언트의 애플리케이션 정보(웹 브라우저 정보, 등등)
  * 통계 정보
  * 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능하다.
  * 요청에서 사용한다.
  * user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/
  537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36
* Host
  * 요청한 호스트 정보(도메인)
  * 요청에서 사용한다.
  * 필수 헤더
  * 하나의 서버가 여러 도메인을 처리해야 할 때 호스트 정보를 명시하기 위해 사용한다.
  * 하나의 IP 주소에 여러 도메인이 적용되어 있을 때 호스트 정보를 명시하기 위해 사용한다.
* Origin
  * 서버로 POST 요청을 보낼 때, 요청을 시작한 주소를 나타냄
  * 여기서 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러가 발생한다.
  * 응답 헤더의 Access-Control-Allow-Origin와 관련
* Authorization
  * 인증 토큰(e.g. JWT)을 서버로 보낼 때 사용하는 헤더
  * “토큰의 종류(e.g. Basic) + 실제 토큰 문자”를 전송한다.
  * Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l

## 응답 헤더

* Server
  * 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보
  * 응답에서 사용
  * Server: Apache/2.2.22 (Debian), Server: nginx
* Date
  * 메시지가 발생한 날짜와 시간
  * 응답에서 사용
  * Date: Tue, 15 Nov 1994 08:12:31 GMT
* Location
  * 페이지 리디렉션
  * 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 리다이렉트(자동 이동)
  * 201(Created): Location 값은 요청에 의해 생성된 리소스 URI
  * 3xx(Redirection): Location 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킴
* Allow
  * 허용 가능한 HTTP 메서드
  * 405(Method Not Allowed)에서 응답에 포함
  * Allow: GET, HEAD, PUT
* Retry-After
  * 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
  * 503(Service Unavailable): 서비스가 언제까지 불능인지 알려줄 수 있음
  * Retry-After: Fri, 31 Dec 2020 23:59:59 GMT(날짜 표기), Retry-After: 120(초 단위 표기)

## 콘텐트 협상 헤더

* 클라이언트가 선호하는 표현 요청
* 요청 시에만 사용한다.
* Accept : 클라이언트가 선호하는 미디어 타입 전달
* Accept-Charset : 클라이언트가 선호하는 압축 인코딩
* Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
* Accept-Language : 클라이언트가 선호하는 자연 언어
  * 적용되지 않았다면 기본 언어인 영어로 응답한다. 
  * 한국어가 없다면 받을 수 있는 우선순위를 설정할 수 있다.

## 캐시 관련 헤더

* 캐시가 없을 경우 동일한 리소스를 요청하더라도 네트워크를 통해 같은 데이터를 또 다운받아야 한다.
* Cache-control
  * max-age : 캐시가 유효한 시간 설정 (seconds)
  * no-cache : 데이터는 캐시해도 되지만 항상 origin 서버에 검증하고 사용한다.
  * no-store : 데이터에 민감한 정보가 있으므로 저장하면 안된다.
* Last-modified : 데이터가 마지막으로 수정된 시간 정보 포함
  * If-modified-since
  * 캐시에 저장할 때 데이터 최종 수정 일도 저장한다.
  * 요청 시 서버의 해당 리소스 최종 수정일과 비교하여 데이터가 수정이 되지 않았을 때 이를 응답 메시지로 알려준다.
  * 캐시는 갱신되어 정해진 시간 동안 유효하다.
  * `304 Not Modified`
  * 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드 하기 때문에 실용적이다.
  * 단점
    * 1초 미만 단위로 캐시 조정이 불가능하다. 
    * 날짜 기반의 로직을 사용한다. 
    * 데이터를 수정하여 날짜가 다르지만 같은 데이터를 수정해서 데이터 결과가 똑같은 경우 다운로드한다.
* ETag
  * If-None-Match
  * entity tag
  * 캐시용 데이터에 임의의 고유한 버전 이름을 달아준다.
  * 데이터가 변경되면 이 이름을 바꾸어서 변경한다.
    * Hash를 다시 생성하는 방식
  * ETag만 보내서 같으면 유지, 다르면 다시 받는 형식이다.
  * 서버에서 캐시를 완전히 컨트롤하고 싶은 경우 사용한다.
  * 작동 방식
    1. 서버에서 헤더에 ETag를 작성해 응답한다.
    2. 클라이언트의 캐시에서 해당 ETag 값을 저장한다.  
    3. 캐시 시간이 초과되어 다시 요청을 해야 하는 경우라면 이떄 ETag 값을 검증하는 If-None-Match를 요청 헤더에 작성해서 보낸다.
    4. 서버에서 데이터가 변경되지 않았을 경우 ETag는 동일하기에 그래서 If-None-Match는 거짓이 된다.
    5. 서버에서는 304 Not Modified를 응답하며 이때 역시 HTTP Body는 없다.
    6. 브라우저 캐시에서는 응답 결과를 재사용하고 헤더 데이터를 갱신한다.
    7. 브라우저는 캐시에서 조회한 데이터를 렌더링한다.
* Expires
  * 캐시 만료일 지정
  * 만료일을 정확한 날짜로 지정한다.
  * HTTP 1.0부터 사용한다.
  * 지금은 더 유연한 Cache-Control : max-age 사용을 권장한다.

### Proxy Cache

* Proxy : 클라이언트와 서버 사이에 대리로 통신을 수행하는 것
* Proxy Server : 그 중계 기능을 하는 서버
* 클라이언트, 혹은 반대로는 서버가 다른 네트워크에 간접적으로 접속할 수 있기 때문에, 보안, 캐싱을 통한 성능, 트래픽 분산 등의 장점이 있다.
* 서버와 클라이언트 사이에 프록시 캐시 서버를 두고 자료를 관리한다.
  * 여러 명이 검색한 자료가 이미 프록시 캐시에 저장되어 있어 클라이언트가 더 빨리 자료를 가져올 수 있다.
  * private cache : 클라이언트에서 사용하고 저장하는 캐시
  * public cache : 프록시 캐시 서버의 캐시
* Cache-control
  * public : 응답이 퍼블릭 캐시에 저장되어도 된다.
  * private : 응답이 해당 사용자만을 위한 것이므로 프라이빗 캐시에 저장해야 한다.
  * s-maxage : 프록시 캐시에만 적용되는 max-age
  * no-cache : 캐시해도 되지만 항상 원 서버에 검증하고 사용
    * 캐시 무효화 시 추가한다.
    * 프록시 캐시 서버와 원 서버 간 네트워크 연결이 단절되어 접근이 불가능하다면 오래된 데이터라도 보여주자는 개념으로 200 OK를 리턴한다. 
  * no-store : 민감한 정보라 저장하면 안 된다.
    * 캐시 무효화 시 추가한다.  
  * must-revalidate : 캐시 만료 후 최초 조회 시 원 서버에 검증해야 한다.
    * 캐시 유효 시간이라면 캐시를 사용한다.
    * 캐시 무효화 시 추가한다.
    * 원 서버에 접근이 불가능할 때 504 오류를 리턴한다.
      * 실시간 값이 중요한 정보의 경우 예전 데이터로 뜨면 안되기 때문에 must-revalidate를 사용한다.  
* Pragma : no-cache
  * HTTP 1.0 하위 호환
  * 캐시 무효화 시 추가한다.
* Age: 60
  * 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간 (초)