# Web2.0 인센티브 기반 커뮤니티 구현

* 인센티브 기반 커뮤니티
  * 인센티브 기반
    * 자체적인 토큰을 가지고 참여자를 유도하는 생태계 빌딩
    * 사용자가 어떠한 행동을 했을 때 토큰을 인센티브로 지급하는 것
* 이번 과정은 중앙화된 서버와 데이터베이스를 이용하여 개발하는 아키텍쳐
  * 클라이언트
    * 지갑 생성
    * 서버에서 지갑 주소 조회
  * 서버
    * 지갑 생성
    * 디비에 사용자 정보, 지갑 주소 저장
  * 데이터베이스
  
## Bare Minimum Requirements

* 서버를 개발할 수 있다.
  * 니모닉 월렛을 개발할 수 있다.
  * Express를 사용하여 라우팅 분기를 할 수 있다.
* DB를 개발할 수있다.
  * MySQL or MongoDB를 사용하여 서버와 연결할 수 있다.
* 회원 가입 기능 개발

## 중앙화된 서버에서 사용자 계정 관리

* 프로젝트에 사용할 데이터베이스를 생성
```sql
CREATE TABLE `users` (
  `id` int PRIMARY KEY AUTO_INCREMENT,
  `userName` varchar(255),
  `password` varchar(255),
  `created_at` timestamp,
  `address` varchar(255),
  `privateKey` varchar(255)
);
```
* API 개발
* 이름, 비밀번호 요청
* API 흐름(수도코드)
  * 서버에서는 요청에 대해, DB 쿼리문으로 데이터를 찾습니다.
    * 데이터가 이미 있으면, 있음을 응답합니다.
    * 데이터가 없으면 저장합니다.
  * 데이터 저장은 니모닉 월렛 생성과 함께 진행됩니다.
    * 먼저, 니모닉 코드를 생성합니다.
    * 생성된 니모닉 코드와 비밀번호를 이용하여, keyStore, address 를 생성합니다.
    * 해당 사용자의 DB 데이터를 업데이트하고, 지갑 주소를 사용자에게 보냅니다.

## 커뮤니티 개발

* 우리가 만들 커뮤니티는 로그인을 하거나 글을 작성할 때, 댓글을 작성할 때마다 커뮤니티 토큰을 발행한다.
* 중앙 서버용 계정을 생성하고, ERC20 토큰 컨트랙트를 배포한 후, 사용자에게 중앙 서버가 가지고 있는 토큰을 하나씩 제공하는 API를 작성
* 중앙 서버용 계정 생성하기
  * 서버는 ERC20 컨트랙트를 배포하고, 클라이언트의 행동에 따라 토큰을 지급합니다. 따라서 가나슈 로컬 네트워크에 중앙서버 계정을 생성

```sql
{
	userName: "server",
	password: "server",
	address: "새로 만든 지갑의 주소",
	privateKey: "새로 만든 지갑의 개인키"
}
```
* 서버 계정이 트랜잭션을 보내기 위해서는 트랜잭션 수수료(가스비)가 있어야한다.
* API 문서를 바탕으로 다음의 순서에 따라 코드를 작성
* 이더를 전송하는 트랜잭션을 보냅니다. 개인키를 사용해 트랜잭션에 서명을 하고 트랜잭션을 보내는 방식을 사용합니다.
  * 데이터베이스에서 가져온 개인키를 사용해 트랜잭션에 서명을 하기 위해서는 개인키를 web3.eth.accounts에 등록해야 합니다. web3.eth.account.privateKeyToAccount() 메서드를 사용하면 개인키를 등록할 수 있습니다.
  * 트랜잭션에 서명을 하기 위해서는 web3.eth.accounts.signTransaction 메서드를 사용합니다.
  * 서명한 트랜잭션을 전송하기 위해서는 web3.eth.sendSignedTransaction 메서드를 사용합니다.
  * 각 메서드가 어떤 인자를 받고, 어떤 값을 리턴하는지 확인하세요.
* 트랜잭션의 결과에 따라 응답합니다.
  * API 문서의 형식에 맞춰 응답합니다.
* 가나슈 로컬 네트워크에 ERC20 컨트랙트 배포
  * 스마트 컨트랙트를 배포하기 위해서는 컨트랙트의 ABI와 Bytecode가 필요합니다. 따라서 remix.ethereum.com 또는 solc를 사용해 컨트랙트를 컴파일하고 ABI와 Bytecode를 가져와 변수로 저장
  * 스마트 컨트랙트 객체를 생성
    * new web3.eth.Contract() 메서드를 사용하면 스마트 컨트랙트 객체를 만들 수 있습니다.
  * 서버 계정으로 스마트 컨트랙트를 배포
    * myContract.deploy() 메서드를 사용하면 우리가 만든 스마트 컨트랙트 객체를 배포할 수 있습니다.
    * myContract.deploy().send() 메서드를 사용해 컨트랙트 배포 트랜잭션을 보낼 수 있습니다.
* ERC20 토큰 제공하기
  * 입력받은 username을 가지고 데이터베이스에 저장되어 있는 주소를 가져옵니다.
  개인키를 사용해 트랜잭션에 서명을 하고 ERC20 컨트랙트의 transfer() 함수를 호출하는 트랜잭션을 보냅니다.
  컨트랙트의 transfer() 함수를 사용해 서버 계정에 있는 토큰 1개를 사용자의 주소로 전송합니다.
  POST /ethFaucet과 동일한 방식으로 트랜잭션에 서명을 하고 보냅니다.
  컨트랙트에 있는 함수를 실행하기 위해서는 트랜잭션에 data 값을 추가해야 합니다.
  참고자료: How can I transfer tokens of my ERC20 automatically from the server?
  컨트랙트의 balanceOf() 함수를 사용하면 특정 주소에 있는 토큰의 갯수를 확인할 수 있습니다.
  트랜잭션의 결과에 따라 응답합니다.
  API 문서의 형식에 맞춰 응답합니다.
* Ropsten 네트워크에서 컨트랙트 배포하고 사용하기
  * 앞서 Infura를 사용해 이더리움 네트워크에 API 엔드포인트 형태로 접근하고 상호작용할 수 있다는 것을 학습했습니다.
  * 이번에는 가나슈 로컬 네트워크가 아닌 이더리움 Ropsten 네트워크에서 진행해봅시다. 가나슈 로컬 네트워크와는 다르게, Ropsten 네트워크에서 유의할 점은 다음과 같습니다.
  * 가나슈 로컬 네트워크에서는 가상 계정으로부터 1 ETH를 받았습니다. 이더리움 Ropsten 네트워크에서는 어떻게 이더를 받을 수 있을까요?
  * 니모닉 월렛으로 서버 계정을 만든 경우, 트랜잭션이 정상적으로 보내지나요?
* 데몬 생성
  * web3, db, pm2, path, fs
  * ganache 실행 & ERC20 스마트 컨트랙트 배포
    Web3를 localhost에 연결 & 블록 조회
    getBlockNumber 등 블록조회 메소드를 이용해 블록 데이터 요청
    getTransaction 과 같이 트랜잭션 조회 메소드를 이용해 블록 데이터 내의 트랜잭션 데이터 요청
    Database 연결 & 테이블 생성
    2의 트랜잭션 데이터를 데이터베이스에 기록
    crontab, pm2 등을 이용해 데몬을 주기적으로 실행
* 이번에는 ERC20의 transfer() 함수를 호출하는 setTransfer() 함수를 만들어, 커뮤니티 유저가 다른 유저에게 토큰을 보낼 수 있도록 합니다.
  * username과 password를 인자로 받아 데이터베이스에 저장된 유저 정보를 조회해서 개인키와 주소를 가져와야 합니다
  * Token을 보내기 전에 데이터베이스에 저장된 toAddress 회원의 잔액을 확인 합니다.
    토큰 전송 함수를 사용 후 반환값인 Txhash를 통해 정상적으로 트랜잭션에 기록 되었는지 확인 합니다.
    balanceOf를 통해 toAddress의 잔액이 변경 되었는지 확인합니다.
    변경된 상태 및 잔액을 데이터베이스에 Update 합니다.
    각 메서드가 어떤 인자를 받고, 어떤 값을 리턴하는지 확인합니다.
* NFT 구매 기능??
* Mint Token
  * Server → ERC-20(mintToken) → User
* NFT Buy
  * Server → ERC-721(mintNFT) → ERC-20(TransferFrom) → User
* MultiMintToken 구현
  * 특정 조건에 따라 너무 많은 트랜잭션이 매번 발생할 수 있다.
  * 오프체인 솔루션을 도입해 한번에 사용자 행동 데이터를 수집하고, 특정 시간마다 모여있는 데이터만큼 토큰을 전송할 수도 있다. 