# Bitcoin script

* 스크립트
* 비트코인에서 스마트 컨트랙트를 구현하는 언어
* 비트코인에서 사용하는 스크립트를 비트코인 스크립트라고 부른다.
* 어떤 공식적인 문법이나 구문이 없다.
* 간단한 연산 목록으로 구성되어 있다.
* 스크립트에서 사용하는 연산들은 opcode에 해당한다.
  * 연산들은 C++로 작성되어 있다.
* 스크립트는 트랜잭션에 연결되어 있다.
* 네트워크의 모든 노드는 트랜잭션을 받을 때마다 자신의 로컬 컴퓨터에서 트랜잭션에 연결된 스크립트를 실행하며 이를 통해 비트코인의 송금이 이루어진다.
  * 프로그래밍 가능한 화폐 programmable money 에 대중성을 부여했다.
* 트랜잭션은 블록체인에 한 번 올라가면 위변조가 매우 어렵다.
  * 모든 노드는 동일한 스크립트를 실행하고, 정확히 동일한 결과를 얻게 된다.
  * 악의적인 노드가 변조한 트랜잭션을 퍼트린다면 변조된 트랜잭션의 스크립트 실행 결과와 다른 트랜잭션의 스크립트 실행 결과가 달라진다.

## 입력값과 출력값

* 비트코인 트랜잭션은 입력 inputs 와 출력 outputs 목록을 가지고 있다.
* 입력
  * 연결된 과거의 출력 previous output을 가리키는 포인터와 해제 키를 가지고 있다. 
  * 입력 구조
    * prev. TX ID, TxIndex: 해제하고자 하는 이전의 출력을 가리키는 포인터
    * ScriptSig : 이전의 출력을 해제하는 키
* 출력
  * 잠금 lock 과 값을 가지고 있다. 
  * 출력 구조
    * ScriptPubKey : 잠금. ScriptPubkey의 소유자(해당 공개키의 소유자)만이 ScriptSig를 만들 수 있다.
    * amount : 잠긴 비트코인의 양
* 노드는 피어로부터 트랜잭션을 받으면 해당 트랜잭션 안에 들어있는 입력과 출력 목록에서 각 입력과 출력에 해당하는 ScriptPig와 ScriptPubkeys를 추출한다.
* 기존 블록들을 찾아보며 입력과 연결된 이전 출력을 찾고, 각 입력과 출력에 들어있는 ScriptSig와 ScriptPubkey를 연결시켰다.
* ScriptSig와 ScriptPubkey는 각각 연속적인 정보를 담고 있다.
  * 노드가 ScriptSig와 ScriptPubkey를 연결한다.
  * 연결한 전체 시퀀스를 파싱하면 온전한 스크립트 코드가 나타나게 된다.
  * 노드는 이 코드를 단계별로 실행한다.

## 스크립트 동작 원리

* 역폴란드 표기법 reverse polish notation 으로 작성된 스택 기반 튜링 불완전 언어
  * 스택 구조로 작동한다는 것이 중요하다.
  * stack 
    * 스택
    * FILO first in last out
    * 가장 나중에 들어온 감자칩이 가장 먼저 나가게 된다.
  * 스크립트는 빈 스택에서 시작하며 이 스택에서 데이터로 들어오거나 push 나가게 된다 pop.
* 스크립트 프로그램은 두 종류의 객체를 가지고 있다.
  * opcode
    * 덧셈, 뺄셈, 곱셈과 같은 연산 작업을 나타낸다.
    * 로우 레벨 기계 언어
    * 약 140 종류의 연산이 있다.
      * 스택 조작 연산 : POP, PUSH, DUP, SWAP
      * 산술/비교/비트 연산 : ADD, SUB, GT, LT, OR
      * 환경 연산 : CALLER, CALLVE, NUMBER
      * 메모리 조작 연산 : MLOAD, MSTORE, MSTORE8, MSIZE
      * 스토리지 조작 연산 : SLOAD, SSTORE
      * 프로그램 카운터 관련 연산 : JUMP, JUMPI, PC, JUMPDEST
      * 작업 중지 연산 : STOP, RETURN, REVERT, INVALID, SELFDESTRUCT
  * data
    * OP_CODE가 아닌 모든 데이터는 원시 데이터로 해석되며 스택에 들어간다.
* 스크립트는 Opcode와 DATA를 일렬로 늘어놓은 것이다.
  * pointer 포인터는 일렬로 늘어진 opcode와 데이터를 순서대로 하나씩 가리킨다.
  * 포인터가 데이터를 가리키면 데이터를 스택에 넣고, opcode를 가리키면 스택에서 데이터를 꺼내온다.
  * opcode는 스택에서 데이터를 하나 이상 가져올 수 있지만 중요한 것은 스택 구조이기 때문에 가장 나중에 들어온 데이터부터 가져온다.
* 스크립트 실행이 성공적이면 스택 가장 상단에 있는 요소는 1이 된다.
  * 스크립트를 끝까지 실행했는데 스택 최상단에 1이 아닌 다른 값이 들어있다면 스크립트 실행을 실패한 것으로 간주한다.
* 노드가 네트워크로부터 새로운 트랜잭션을 받으면 ScriptSig와 ScriptPubkey 필드를 추출하고 연결하여 최종적으로 `<ScriptSig><ScriptPubkey>` 형태의 스크립트를 얻게 된다.
* 노드는 이 스크립트와 빈 스택 하나를 사용해 스크립트를 실행하고, 실행이 완료되면 최상위 스택 요소가 1인지 확인한다.
  * 1이면 트랜잭션이 유효하다고 간주하고 노드는 트랜잭션을 주변 노드들에게 전파한다.
  * 트랜잭션이 유효하지 않은 경우 트랜잭션을 보내지 않는다.
    * 이 경우 주변 노드들에게 전파되지 않으므로 네트워크에 트랜잭션이 공유되지 않는다.
  * 트랜잭션은 네트워크에 있는 모든 노드들이 받을 수 있기 때문에 네트워크 모든 노드들은 전체 네트워크의 상태를 지키는 문지기 역할을 한다.

## 자주 쓰이는 비트코인 스크립트

### Pay to PubKey(P2PK)

![P2PK](p2pk.png)

* 두 개의 데이터와 하나의 Opcode만 사용하는 가장 간단한 종류의 비트코인 스크립트
* 비트코인 초기 버전에는 이 유형의 스크립트가 사용되었다.
* P2PK는 퍼블릭 키에 직접 코인을 송금하는데 사용된다.
* 수신자의 공개 키를 직접 노출하기 때문에 보안에 취약하다.
  * 오늘날에는 사용되지 않는다.
* ScriptPubkey는 잠금을 정의하는 데이터 구조
  * 트랜잭션 입력 내부에 존재한다.
  * 트랜잭션 입력이 잠금을 해제하려는 이전 트랜잭션의 출력에서 추출된다.
    * **잠금을 해제한다**
      * ScriptSig와 ScriptPubkey를 연결하여 스크립트 코드로 만들어 실행하고, 실행 후 스택 최상단에 값이 1인 요소를 남기는 프로세스
* ScriptSig 해제 키를 정의하는 데이터 구조
* 전체 P2PK스크립트는 서명 signature, 공개키 public key, OP_CHECKSIG라는 Opcode로 구성된다.
  * OP_CHECKSIG는 서명이 주어진 공개키와 연결되는지 확인한다.
  * 연결되면 스택에 1을 반환하고 그렇지 않으면 0을 반환한다.
  * 순서
    1. 빈 스택에서 포인터가 서명을 가리킨다. <Signature>
    2. 서명은 데이터이므로 스택에 들어간다. 
    3. 포인터는 그 다음 요소인 공개키를 가리킨다. <public key>
    4. 공개 키도 데이터이니 스택에 넣는다.
    5. 포인터는 이제 OP_CHECKSIG를 가리킨다.
    6. OP_CHECKSIG는 스택에서 아이템 두개(공개키와 서명)을 꺼내는 Opcode이다.
    7. OP_CHECKSIG는 스택에서 공개키와 서명을 꺼내고, ECDSA 알고리즘을 사용해 서명을 검증한다.
       1. 검증에 성공하면 1
       2. 검증에 실패하면 0을 스택에 넣는다.
       * ECDSA 알고리즘
         * elliptic curve digital signature algorithm
         * 타원 곡선 알고리즘에 디지털 서명을 추가한 알고리즘
         * 비트코인과 이더리움에서 서명을 검증할 때 사용한다. 
    8. 검증을 마치고 스택에 1이 들어있으면 트랜잭션 검증을 완료하고 UTXO가 해제된다.
    9. 크립트가 성공적으로 실행되면 트랜잭션은 유효한 것으로 간주된다.
    10. 이전 UTXO가 소비되고, 해당 트랜잭션의 출력 목록에 따라 새로운 UTXO가 생성된다.

### PayToPubKeyHash(P2PKH)

![P2PKH](p2pkh.png)

* P2PK 매커니즘과 거의 동일하다.
  * P2PKH에서는 ScriptPubkey가 공개 키의 해시값을 가지고 있다.
  * UTXO는 수신자의 공개 키를 공개 할 필요가 없다. 
* 순서
  1. 빈 스택에서 포인터는 서명을 가리킨다. <signature>
  2. 서명은 데이터이기 때문에 스택에 들어간다.
  3. 포인터는 다음 요소인 공개 키를 가리킨다. <public key>
  4. 공개 키도 데이터이기 때문에 스택에 들어간다. 
  5. 포인터는 다음 요소는 OP_DUP을 가리킨다.
  6. OP_DUP은 스택 최상단 요소를 복사하는 Opcode이다.
  7. OP_DUP이 실행되면 스택에는 공개 키가 두 개 쌓이게 된다.
  8. 포인터는 다음 요소인 OP_HASH160을 가리킨다.
  9. OP_HASH160은 스택 최상단 요소를 해싱하는 Opcode이다.
  10. 최상단ㅁ에 있는 공개 키가 해싱되어 Hash 2가 된다.
  11. 포인터는 그 다음 요소인 Hash 1을 가리킨다.
  12. Hash 1은 데이터이기 때문에 스택에 쌓인다.
  13. 포인터는 다음 요소인 OP_EQUALVERIFY를 가리킨다.
  14. OP_EQUALVERIFY는 스택에 있는 두 요소가 같은지 확인하는 op_code이다.
      1. 만약 두 요소가 같다면 해당 요소 두 개를 제거한다.
         1. ScriptSig에 올바른 공개 키가 들어있었다면 ScriptPubKey에 들어있던 Hash 1과 공개키를 해싱한 값인 Hash 2가 동일할 것이고, 스택에서 제거된다.
      2. 두 요소가 다르다면 실행에 실패하게 된다.
  15. 포인터는 다음 요소인 OP_CHECKSIG를 가리킨다.
  16. OP_CHECKSIG는 앞서 P2PK와 동일하게 동작한다.
      1.  ECDSA알고리즘으로 서명을 검증하고, 서명이 올바르다면 스택에 1을 쌓는다.
          1.  실행이 완료되고 1이 남아있다면 검증이 성공한 것이고, UTXO가 해제된다.
* P2PKH가 서명에 대해 공개 키로 검증을 한다는 점에서 P2PK 스크립트와 동일하다.
* 공개 키가 아닌 공개 키 해시값을 사용한다는 점에서 우회적인 방식으로 좀 더 좋은 프라이버시를 제공한다.

* 이외에 직접 스크립트를 작성할 수 있다.
* regtest라는 비트코인 테스트 네트워크에서 테스트할 수 있다.
* btcdeb라는 CLI를 사용해 스크립트를 디버깅할 수 있다.

### 비트코인 스크립트가 스마트 컨트랙트인 이유

* UTXO의 ScriptPubkey는 일종의 수학적 퍼즐의 형태이다.
  * 올바른 ScriptSig를 추가함으로써 퍼즐을 풀 수 있다.
* 예
  * 트랜잭션의 입력과 연결된 출력에 다음과 같은 ScriptPubkey와 ScriptSig가 들어있다.
    * ScriptPubkey : `2 2 OP_ADD OP_EQUAL`
    * ScriptSig : `4`
  * 이러한 ScriptPubkey를 가진 UTXO는 위의 ScriptSig를 통해서 해제된다.
  * ScriptSig값이 3이나 5였다면 OP_EQUAL(스택의 두 요소를 꺼내 같은지 확인하는 Opcode)의 결과갑싱 거짓이 되어 UTXO가 해제되지 않았을 것이다.
* UTXO는 일종의 계약으로 정의될 수 있다.
  * 유효한 해제 조건이 주어지면 잠긴 비트코인을 이동시킨다.
  * 유효한 해제 조건이 주어져야 코인을 송금할 수 있는 계약이다.
  * 비트코인 네트워크가 보장하기 때문에 계약 이행을 강제하기 위한 중개자가 필요하지 않다.
