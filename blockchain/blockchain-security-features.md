# 블록체인의 보안적 특징

## 기존 시스템과의 비교

* 기존 데이터베이스
  * 클라이언트-서버 아키텍쳐를 사용
  * 클라이언트는 중앙 서버에 저장된 데이터를 수정할 수 있다.
  * 데이터베이스 관리자는 사용자가 데이터베이스에 대한 권한을 가지고 있는지 확인한 후 접근을 허용한다.
    * 관리자에게 데이터베이스에 대한 통제권이 있다.
    * 악의적인 해커에 의해 데이터베이스 관리자 계정을 탈취당하면, 데이터베이스가 악의적인 해커에 의해 임의로 조작될 수 있기 때문에 무결성이 깨질 수 있다.
    * 기존 데이터베이스에서는 데이터베이스의 무결성과 투명성을 관리자가 보장해야 하기 때문에, 관리자 계정이 탈취되는 등 관리자에게 문제가 생기는 경우 데이터베이스에 큰 보안적 위험이 생긴다.
  * 클라이언트는
    * 데이터베이스 관리자가 부여한 권한에 따라 CRUD라고 불리는 데이터 생성, 읽기, 업데이트, 삭제 작업을 수행한다.
  * 중앙 통제 방식이기 때문에 관리자라는 단일 공격 지점이 존재한다.
    * 해커가 관리자를 공격하는 데 성공한다면 데이터베이스 권한을 얻게 되기 때문에, 해커가 데이터를 파괴하거나 변조할 수 있다.
    * 사용자는 데이터베이스 관리자의 보안 인프라에 의존해야 하며, 데이터베이스 관리를 위한 보안 유지 비용이 소모될 수 밖에 없다.
* 블록체인
  * 분산 시스템
  * 각 노드들이 블록체인 사본을 가지고 있으며, 일부 노드에 문제가 발생해도 전체 블록체인 네트워크의 무결성은 보장된다.
  * 블록체인의 모든 노드는 오직 데이터를 읽거나 추가할 수만 있다.
    * 이전의 모든 데이터는 영구적으로 저장되며, 한 번 기록된 데이터는 변경하거나 삭제할 수 없다.
  * 분산 데이터 저장 방식을 사용하기 때문에 단일 공격 지점이 없고, 위와 같은 문제를 사전에 차단한다.

### 블록체인의 보안적 특징

* 데이터 무결성
  * 무결성은 데이터베이스가 데이터의 정확성과 일관성을 유지하는 것을 의미한다.
  * 블록체인에서는 합의 알고리즘을 사용해 데이터의 무결성을 보장한다. 
  * 합의 알고리즘을 통해 블록에 입력된 데이터에 대해 분산된 각 노드들이 모두 동일한 결과를 가질 수 있도록 한다. 
  * 만약 네트워크에 악의적인 노드가 참여하더라도, 합의를 통해 노드가 블록을 변조하지 못하도록 하여 전체 네트워크의 신뢰도를 감소시키지 않도록 한다.
  * 다시 말해, 합의 알고리즘은 네트워크 상에 존재하는 신뢰할 수 없는 노드들이 절차에 맞게 상호 검증하여 네트워크 전체의 무결성을 보장하는 알고리즘이다.
* 거래 투명성
  * 퍼블릭 블록체인의 경우, 누구나 블록체인 네트워크에 접속해 트랜잭션 기록을 확인할 수 있다.
  * 프라이빗 블록체인도 허가된 사용자라면 누구나 트랜잭션 기록을 볼 수 있다.
  * 거래 기록에 누구나 공개적으로 접근할 수 있기 때문에, 송금 과정을 투명하게 하기 위한 규제 비용을 절감할 수 있다.
* 감시 가능성
  * 블록체인은 데이터 추가만 가능한(Append-Only) 데이터베이스로, 한번 블록이 체인에 올라가면 블록에 담겨있는 트랜잭션이나 데이터는 수정할 수 없다.
  * 이 과정에 사용되는 핵심적인 기술이 바로 해시 알고리즘이다
    * 새로 생성되는 블록의 헤더에는 이전 헤더의 해시 값이 포함되어 있기 때문에, 연결된 모든 블록의 무결성 검증에 사용된다.
  * 블록에 담긴 트랜잭션을 나타내는 머클 트리의 루트 해시값이 블록 헤더에 함께 포함되어 있다.
  * 트랜잭션에 변경이 일어나면 머클 해시 값이 변경되므로, 블록체인에 대한 위변조 시도를 바로 발견할 수 있다.

## 이중지불 문제

* Double Spending
* 디지털 현금 시스템 내에 동일한 하나의 자산이 두 명의 수신자에게 동시에 전송되는 문제
  * 예
    * 가령 A가령 A가 자신의 계좌에 있는 2,000원을 B에게 보내는데, 해당 송금이 처리되기 전 A가 다시 아직 자신의 계좌에 있는 2,000원을 C에게 송금하도록 요청할 때를 가정한다. 
    * A가 자신의 ‘2,000원’이라는 자산 데이터를 복제하여 B에게도 보내고 C에게도 보낸다.
    * 정상적이라면 A가 B에게 보내는 송금이 먼저 처리되어 C에게 보내는 송금은 완료되지 않을 것이다.
    * 그러나 디지털 시스템의 허점으로 인해 C에게 보내는 송금도 처리가 될 수도 있다.
* 이중 지불 문제를 해결하지 못한다면, 사용자는 자신이 전달받은 자금이 다른 어딘가에서 이미 사용되지 않았다는 것을 검증할 방법이 없다.
* 디지털 금융 시스템에서는 특정 자산이 복제될 수 없게 하는 것이 가장 중요하다.
  * A가 자신의 자산을 열 번 복제하여 2,000원을 20,000원으로 만든다면 해당 금융 시스템 자체가 붕괴될 것이다.
* 디지털 자산의 복제를 막는 것은 어려운 문제이지만, 이러한 문제를 방지할 수 있어야 디지털 현금 시스템을 사용할 수 있다.

### 이중지불 문제를 막는 방법

#### 중앙화된 접근법

* 중앙화된 방법은 탈중앙화된 방법에 비해 간단하다. 
* 일반적인 시스템에는 해당 시스템을 관리하는 감독이 있으며, 감독은 자산의 발행과 분배를 관장한다.
* 이중 지불 문제를 해결하는 중앙화된 접근법의 대표적인 예시
* David Chaum 데이비드 차움의 eCash
  * 암호학자 데이비드 차움은 자신의 논문 에서 은행이 고객에게 익명성을 보장하고 P2P 교환이 가능한 디지털 자산을 발행하기 위한 방식으로 은닉 서명(Blind Signature)을 제안한다.
* eCash의 동작방식
  * Case 1
    * 사용자가 자신의 계좌에 있는 100달러를 디지털 현금으로 바꾸고 싶은 경우
    1. 사용자는 먼저 자신의 계좌에 있는 100달러를 디지털 현금으로 바꾸고 싶다고 은행에 알린ㄴ다.
    2. 은행은 사용자의 계좌에 잔액이 있는지 확인하고, 하나 또는 여러개의 임의의 숫자를 생성합니다.
    3. 사용자가 다섯 개의 숫자를 생성했다면, 각 숫자는 20달러에 해당하게 됩니다. (사용자가 두 개의 숫자를 생성했다면 각 숫자는 50달러에 해당) 이 숫자는 디지털 현금 지폐처럼 사용된다.
    4. 사용자는 은행이 자신의 숫자를 추적할 수 없도록 각 숫자에 은닉 요소(Blinding Factor)를 추가된다.
    5. 이후 사용자는 은닉 요소를 추가한 숫자 데이터를 은행에 넘겨준다.
    6. 은행은 사용자의 계좌에서 100달러를 인출하고, 5개의 데이터로 각각 20달러씩 교환할 수 있음을 증명하는 메시지에 서명한다.
    7. 사용자는 이제 은행에서 발행된 자금을 사용할 수 있다.
  * Case 2
    * 디지털 현금으로 결제를 하고 싶은 경우
    1. 사용자가 레스토랑에서 40달러짜리 메뉴를 먹는 경우, 사용자는 자신의 숫자 중 음식값을 지불하기 위한 숫자 두 개의 은닉 요소를 제거하여 레스토랑 주인에게 건네준다.
    2. 레스토랑 주인은 사용자가 다른 상점에서 이 숫자 두 개를 다시 사용하는 것을 방지하기 위해 이를 즉시 은행에 청구한다.
    3. eCash를 그대로 가지고 있으면, 사용자가 다른 곳에서 이 40달러를 또 사용할 수 있기 때문이다.
    4. 은행은 레스토랑 주인이 제시한 숫자에 있는 서명이 유효한지 확인하고, 정확하다면 레스토랑 주인에게 40달러를 입금한다.
    5. 사용된 숫자는 소각됩니다.
* eCash는 비밀 송금에 유용히다. 
  * 디지털 현금은 기본적으로 숫자로 구성되며, 은행에서 서명을 하기 때문에 당사자들의 신원을 확인할 필요가 없기 때문이다.
* 은행 자체가 단일 장애 지점이기 때문에, 은행에 문제가 생길 경우 결제 시스템 전체에 문제가 생길 수 있다. 
  * 발행된 숫자, 즉 지폐는 그 자체로는 아무런 의미도 없으나 은행이 그 가치를 부여하고 보증하기 때문이다.
* eCash에서 고객은 은행의 통제 아래에 있으며, 돈을 사용하기 위해서는 은행의 허가를 받아야 한다.
  * 바로 암호화폐가 해결하고자 하는 문제입니다.

#### 탈중앙화된 접근법

* 중앙화된 감독이 없는 생태계에서 이중 지불을 방지하는 것은 더욱 어렵다.
  * 균등한 힘을 가진 참여자들이 서로 부정 행위를 방지하고 정직하게 행동할 수 있도록 장려하기 위해 일련의 규칙을 마련하고 협력해야 한다.
* 이중 지불 문제에 대한 가장 혁신적인 해결책은 비트코인 백서에서 확인할 수 있다.  
  * 사토시 나카모토가 제시한 데이터 구조 블록체인
* 블록체인의 특별한 속성을 가진 데이터베이스이다.
  * 비트코인 코어, geth 등 특정 소프트웨어를 실행하면 누구든지 블록체인 네트워크에 참여할 수 있다. 
    * 노드
      * 소프트웨어를 실행하여 네트워크에 연결된 컴퓨터
    * 네트워크에 참여한 모든 노드는 블록체인의 데이터베이스 사본을 다운로드 받고, 다른 노드들과 동기화할 수 있다.
  * (퍼블릭 블록체인의 경우) 누구나 언제든지 네트워크에 참여하여 제네시스 블록부터 최신블록까지 모든 트랜잭션을 확인할 수 있다.
    * 이중 지불을 시도하는 부정 트랜잭션을 감지할 수 있다.
    * 사용자가 트랜잭션을 전송하면 이는 바로 블록체인에 추가되지 않고, 채굴을 통해 먼저 하나의 블록에 포함시켜야 한다. 
      * 트랜잭션은 생성되었을 때가 아니라, 트랜잭션이 포함된 블록이 체인에 추가되었을 때 유효하다고 간주된다. 
        * 그렇지 않으면, 송신자가 하나의 코인으로 여러 트랜잭션을 생성하여 받은 자금을 잃어버릴 수 있다.
      * 트랜잭션이 체인에 올라가 확정되면 새로운 사용자에게 소유권이 할당되기 때문에 코인은 이중지불 될 수 없다.
        * 때문에 트랜잭션을 유효한 것으로 간주하기 전에 많은 이들이 복수의 승인을 기다릴 것을 추천하는 이유 
        * 체인으로 이어진 각 블록을 수정하는 데에는 엄청난 노력이 필요하기 때문이다.
* 레스토랑 예시
  * 이 레스토랑은 이번주부터 비트코인으로도 결제를 할 수 있다. 
  1. 김코딩은 지난 번에 먹었던 메뉴를 다시 주문한다. 가격은 0.005 BTC라고 합니다.
  2. 레스토랑 주인은 김코딩에게 음식값을 지불할 비트코인 주소를 알려준다.
  3. 김코딩은 자신의 소유였던 0.005BTC가 레스토랑 주인의 소유라고 주장하는 내용과 이를 서명한 트랜잭션을 생성하고, 네트워크의 다른 노드들에게 전송한다.
  4. 서명된 트랜잭션을 통해 네트워크에 연결된 모든 노드들은 트랜잭션을 자세하게 뜯어보지 않아도 김코딩의 서명을 통해 김코딩이 실제로 해당 0.005BTC의 소유자였으며, 이를 송금할 권한이 있음을 검증할 수 있다.
  5. 트랜잭션은 체인에 블록이 올라가야 유효하다. 트랜잭션이 블록에 올라가고, 블록이 체인에 연결되어야 실제로 송금이 완료된 것이다.
     * 만약 체인에 올라가지 않은 블록에 기록된 트랜잭션을 수용하는 것은 eCash에서 40달러를 은행에 청구하지 않고 그대로 가지고 있는 것과 같다. 
     * 트랜잭션이 블록에 올라가 체인에 연결되지 않은 경우, 다른 노드들은 이 트랜잭션이 처리되지 않은 것이라고 판단하기 때문에 김코딩이 0.005BTC를 가지고 있는 것이나 마찬가지입니다.
* 블록이 체인에 연결되더라도, 트랜잭션이 완전히 처리된 것은 아니다.
  * 컨펌 횟수
    * 실제로 블록에 있는 트랜잭션이 수정이 불가능하다고 판단되어 온전히 완료되는 시점은 블록이 체인에 올라가고 자신의 뒤에 블록이 일정 갯수 이상 연결된 시점입니다. 
  * 블록이 체인에 올라가더라도, 만약 체인이 두 갈래로 갈라진 상태에서 블록이 추가되었다면, 체인 재구성이 일어나 해당 블록이 고아블록이 되어 트랜잭션이 취소될 수도 있기 때문이다.
  * 비트코인에서는 특정 블록 뒤에 6개의 블록이 더 쌓여야 안전하다고 본다. 
    * 블록이 하나 생성될 때 10분이 소요되기 때문에, 트랜잭션이 완료되는 시점은 블록이 체인에 올라간 후 약 1시간이 지난 후이다.

### 비트코인 이중 지불

* 비트코인의 기본 프로토콜
  * 이중 지불 공격을 방어할 수 있도록 세심하게 설계되어 있다. 
    * 송신자를 포함한 그 누구도 체인에 올라간 트랜잭션을 되돌릴 수 없습니다. 
    * 이를 되돌리기 위해서는 해당 블록과, 해당 블록 이후에 생성된 블록들을 되돌려야 한다.
      * 이는 비현실적인 수준의 연산 능력을 필요로 하기 때문이다.
* 트랜잭션을 승인하는 노드를 겨냥한 소규모 이중 지불 공격도 존재한다. 
  * 예
  1. 바쁜 패스트푸드점에서는 트랜잭션이 블록에 포함되기까지 기다리고 싶어하지 않을 것이다. 
  2. 만약 패스트푸드점에서 즉각적인 결제, 즉 블록이 체인에 올라간 시점이 아니라 트랜잭션이 생성된 시점을 결제 시점으로 수용한다면 이중 지불 공격에 노출될 수 있다. 
  3. 누군가가 햄버거를 주문하고, 트랜잭션을 생성해 금액을 지불하고, 동일한 금액을 자신의 다른 주소로 전송할 수 있다. 
  4. 만약 자신의 다른 주소로 전송한 트랜잭션의 수수료가 더 높으면 이 트랜잭션이 먼저 승인될 수도 있으며, 이전에 패스트푸드점에서 생성한 트랜잭션은 무효화될 것이다.
* 이중 지불을 수반한 세 가지 공격 방법
  * 51% 공격
    * 단일 주체나 조직이 50% 이상의 해시 레이트를 가지게 될 경우, 이들은 원치 않는 트랜잭션을 배제하거나 트랜잭션 순서를 조작할 수 있게 된다. 
    * 비트코인에서 해당 공격이 발생할 가능성은 매우 낮지만, 규모가 작은 다른 네트워크에서는 발생할 수도 있다.
  * 레이스 공격(Race Attacks)
    * 동일한 자금을 사용하는 두 개의 충돌하는 트랜잭션이 연속으로 전송되지만, 하나의 트랜잭션만 승인되는 것이다. 
    * 해당 공격의 목표는 앞의 패스트푸드점 예시처럼 두 개의 충돌하는 트랜잭션 중 자신에게 이익이 되는 트랜잭션만 유효하게 만들어 결제를 무효화하는 것이다. 
    * 레이스 공격은 수신자가 체인에 올라가지 않은 트랜잭션을 결제로 수용할 때 가능하다.
  * 핀니 공격(Finney Attacks)
    * 공격자는 네트워크에 즉각적으로 트랜잭션을 전송하지 않고, 코인을 자신의 다른 지갑으로 전송하는 트랜잭션을 미리 생성해두고, 블록을 미리 채굴해두어 해당 블록에 기록한다. 
    * 동일 코인을 다른 트랜잭션에서 사용하는 대신, 이전에 채굴한 블록만을 전송하며, 결제는 무효화된다. 
    * 핀니 공격은 특정한 순서에 따라 사건이 발생해야 하며, 수신자는 체인에 올라가지 않은 트랜잭션을 수용해야 발생 가능하다.
  * 이중 지불은 디지털 현금 시스템에서 경제적 이익을 얻기 위해 동일한 자금을 여러번 사용하는 것이다.
  * 이중 지불 문제는 적절한 해결책이 없었기 때문에, 디지털 현금 시스템의 발전에 큰 걸림돌이 되어 왔다.
* 은닉 서명이 중앙화된 경제 체계에 해결책을 제시했다. 
  * 또한 작업 증명 메커니즘과 블록체인 기술의 개발로 탈중앙화된 자산의 형태인 비트코인이 탄생했으며, 비트코인은 수천 개의 암호화폐 프로젝트에 영감을 주었다.
* 이러한 기존 시스템과의 차이로 인해, 블록체인에 대한 공격 방식도 기존의 데이터베이스 공격 방식과는 다르다. 
  * 블록체인 공격 방식을 미리 알아두고 예방하는 것이 중요하다.

## 블록체인에 위험한 공격

### 51% 공격

* 비트코인의 주요한 강점이자 블록체인 기술의 근간을 이루는 특징은 데이터를 구축하고 검증하는 분산성이다.
* 탈중앙화 방식은 노드들이 프로토콜 규칙을 준수하고, 모든 네트워크 참여자가 블록체인의 현 상태에 동의하도록 한다.
  * 모든 노드는 채굴 과정과 사용중인 소프트웨어의 버전, 트랜잭션의 유효성 등에 정기적으로 합의를 달성해야 한다.
* 비트코인 합의 알고리즘인 작업증명 방식(PoW, Proof of Work)는 채굴 노드가 새로운 트랜잭션 블록을 검증할 수 있도록 한다. 
  * 채굴의 결과인 논스로부터 나온 블록 해시는 채굴 노드가 충분한 작업을 완수했으며, 해당 블록에 대한 유효한 해결책을 찾았음을 증명한다.
  * 작업 증명 기반 시스템에서의 채굴 과정은 막대한 양의 전력과 컴퓨터 자원을 수반하기 때문에, 채굴에 대한 결과는 자신이 보유한 컴퓨터 파워에 기초한다. 
    * 이렇게 해시 값을 찾기 위한 컴퓨터들의 연산 파워를 해시 파워(Hash Power) 또는 해시 레이트(Hash Rate)라고 한다. 
    * 채굴 노드들은 유효한 블록 해시를 찾아 새롭게 생성되는 비트코인을 보상으로 받기 위해 경쟁한다.
* 비트코인 네트워크의 채굴 파워는 전 세계의 다양한 노드들에게 분산되어 있기 때문에, 해시 파워는 어떤 단일 주체의 소유가 아니다.
  * 단일 주체나 조직이 50%가 넘는 해시 파워를 가지게 된다면 51% 공격이 발생할 수 있다.
* 다수 공격(Majority Attack)

#### 개념

* 단일 주체나 조직이 대다수의 해시 파워를 제어하여 네트워크를 중단시킬 수 있는 공격
* 51% 공격을 하기 위해서는 공격자가 트랜잭션 순서를 의도적으로 수정하거나 제외시키기 위해 충분한 채굴 파워를 소유해야 한다.
* 악의적인 주체가 충분한 채굴 파워를 소유하여 통제권을 쥐고 있게 되면, 자신이 발생시킨 트랜잭션을 되돌릴 수 있게 된다.
  * 이는 이중지불 문제로 이어질 수 있습니다. 
* 악의적인 다수가 51% 공격을 성공하게 되면, 공격자들은 트랜잭션의 일부나 전부가 승인되지 못하도록 하거나(트랜잭션 서비스 거부, Transaction Denial of Service), 채굴자들이 채굴을 하지 못하도록 하고 채굴 작업을 독점할 수 있다(채굴 독점, Mining Monopoly).
* 악의적인 다수의 공격은 다른 이들의 트랜잭션을 되돌리거나 네트워크에 전송되는 트랜잭션을 거부할 수 없습니다. 
* 블록 보상을 변경하거나, 코인을 새롭게 생성하거나, 공격자의 소유가 아니었던 코인을 가로채는 작업 역시 발생하기 어렵다.

#### 동작 방식

* 51% 공격은 네트워크 전체 해시 파워의 절반 이상을 확보하여 네트워크를 교란시키는 공격법이다.
* 네트워크를 교란시킬 수 있는 방법
  * 이 공격을 위해서는 네트워크 전체 해시 파워의 50% 이상을 확보해야 한다.
    * 여기서 공격자는 블록체인 네트워크의 전체 해시 파워의 50% 이상을 확보했다고 한다.
1. 공격자는 성능이 좋은 ASIC 장비 등을 도입하여 이더리움 클래식 네트워크에 접속합니다.
2. 공격자의 노드는 50% 이상의 높은 해시 파워로 채굴을 한다. 
   1. 블록체인 네트워크에 노드로 접속하게 해주는 클라이언트 프로그램을 수정해서, 채굴한 블록들을 네트워크에 전파(Broadcast)하지 않고 혼자 가지고 있는다. 이런 식으로 혼자 블록들을 여러 개 생성한다.
   2. 한편, 이더리움 클래식 네트워크에서는 정상적으로 블록을 생성하고 있다.
   3. 그러나 악의적인 노드의 해시 파워는 네트워크의 전체 해시 파워보다 높기 때문에 더 빠른 속도로 블록을 생성합니다.
3. 이 상태에서, 공격자들은 정상 네트워크에서 트랜잭션을 발생시킨다.
   1. 가령 10,000 ETC를 허술해 거래소에 입금한다. 
   2. 이 입금 트랜잭션이 135번 블록에 기록되었다고 할 때, 허술해 거래소는 아무것도 모른 채로 평소대로 30 컨펌이 되면 입금을 처리해준다.
4. 공격자들은 30컨펌(7분 30초)을 기다렸다가 이더리움 클래식을 판다.
   1. 이 시점에서 정상 네트워크에서는 165번 블록까지 생성되었을 것이다.
   2. 반면, 네트워크의 해시 파워보다 더 해시 파워가 높은 공격자의 채굴 장비에서의 블록은 180번까지 생성되었기 때문에 공격자의 체인이 더 긴 상태이다.
5. 공격자가 자신이 만든 체인을 정상 네트워크에 전파한다.
   1. 네트워크에 있는 노드들은 두 개의 체인을 가지게 된다. 정상 네트워크에서 생성된 짧은 체인에 있는 블록들은 고아 블록이 되어 모두 취소된다.
      1. 블록체인에서는 이렇게 체인이 두 개로 나눠졌을 경우, 더 긴 체인을 선택하고, 나머지 체인을 취소한다.
      2. 이렇게 취소된 체인의 블록을 고아 블록(orphan blocks)이라고 한다.
      3. 이 과정을 체인 재구성이라고 한다.
6. 이렇게 체인이 재구성되면, 기존 체인에 있던 트랜잭션(10,000ETC 입금 트랜잭션을 비롯한 정상적인 트랜잭션들)은 무효화된다.
   1. 그러면 허술해 거래소 입금을 취소해야 하는데, 공격자들은 이미 코인을 다른 곳으로 송금한 뒤이기 때문에 취소할 수 없는 상황이 된다. 
      1. 블록체인 입장에서는 10,000ETC 송금이 없던 경우가 되기 때문에, 공격자들의 원래 계좌인 0x1234로 10,000ETC 잔고가 생기게 된다.
   2. 여기서 중요한 것은 공격자들이 만든 체인은 악의적인 체인이지만, 블록체인 입장에서는 가장 긴 체인이기 때문에 정상적인 체인이기 때문이다.
7. 공격자들이 정상 블록체인에서 다시 10,000ETC를 자신들의 또 다른 계좌로 송금하면 공격자들의 입장에서는 10,000ETC를 두번 송금한 것이기 때문에 이중 지불이 된다.
8. 블록체인의 관점에서는 이전 송금은 아예 없던 일이 되버리기 때문에 여전히 정상적인 트랜잭션들로 구성된다는 점에 주목해야 한다. 
   1. 왜냐하면 처음 10,000ETC 전송 트랜잭션은 블록체인 상에서 사라졌기 때문이다. 
   2. 결국 손해는 허술해 거래소가 입게 된다.

* 일반 사용자 입장의 대처
  * 입출금을 가급적이면 하지 않는 것이 최선이며, 특히 입금 받을 때 주의해야 한다. 
  * 자신이 받은 코인이 체인 재구성에 의해 블록체인 상에서 취소될 수 있기 때문에, 체인 재구성이 힘들 만큼 충분한 시간이 지난 후에 입금 처리를 해야 한다. 
    * 거래소들이 입출금을 막거나 입금 컨펌 횟수를 늘리는 것은 이 때문입니다.
* 다른 작업 증명(Proof of Work) 방식을 사용하는 블록체인에게도 이러한 위험이 이론상으로는 존재한다. 
  * 비트코인에서는 전체 해시 파워가 매우 크기 때문에, 51% 공격을 하기 위해서는 어마어마한 해시 파워가 필요하다. 
  * 이를 전력 비용으로 환산하면 매우 많은 돈이 들기 때문에 일반적으로는 51% 공격으로부터는 안전하다고 믿고 있다.
* 작업 증명 방식을 사용하는 블록체인에서는 해시 파워가 곧 안정성을 의미한다. 
  * 네트워크의 해시 파워가 낮으면 적은 전력으로도 50% 이상의 해시 파워를 얻을 수 있기 때문이다.
    * 마찬가지로, 지분 증명(Proof of Stake) 방식에서는 코인의 가치가 낮아지면 네트워크의 안정성이 떨어진다.
* 51% 공격을 보면 알 수 있듯이, 블록 생성 시간은 큰 의미가 없다. 
  * 비트코인은 10분에 한번씩 블록을 생성하고, 이더리움은 15초에 한번씩 블록을 셍상힌디. 
  * 그렇다고 해서 이더리움이 비트코인에 비해 트랜잭션을 더 빠르게 처리하는 것은 아니다.
  * 왜냐하면 체인 재구성 공격에 대비해 일정 컨펌이 지난 후 입금을 처리해야 하기 때문에 블록체인에 "얼마나 빠르게 기록되느냐"보다는 "얼마나 빠르게 컨펌되느냐"가 더 중요한 문제이기 떄문이다.
  * 이 확정 시간은 블록 생성 시간에 좌우된다기 보다는 해시 파워의 크기에 영향을 받게 된다. 
  * 해시 파워가 커서 체인이 안정될 수록 확정 시간을 짧게 잡을 수 있다.

#### 51% 공격이 벌어질 확률

* 블록체인 네트워크가 안전한 이유는 블록체인 네트워크는 분산화된 노드 네트워크에 의해 유지되고, 모든 참가자들은 합의에 도달하는 과정에 협력하기 때문이다.
* 작업 증명 블록체인의 경우
  * 채굴 노드는 높은 해시 레이트를 가지고 있을 수록 다음 블록의 유효한 논스값을 찾을 가능성이 높아진다. 
  * 채굴은 무수히 많은 해싱 시도를 포함하며, 컴퓨터가 더 큰 연산력을 가지고 있을 수록 초당 더 많은 해싱 시도를 할 수 있다.
* 몇몇 초기 채굴자들은 네트워크의 성장과 보안에 기여하기 위해 비트코인 네트워크에 합류했다.
  * 통화로써의 비트코인의 가격이 치솟자 수많은 신규 채굴자들이 블록 보상으로 코인을 받기 위해 네트워크에 합류하였다.
  * 비트코인이 안전한 이유 중 하나는 바로 이런 경쟁적 시나리오 때문입니다.
* 경쟁적 시나리오로 인해 비트코인의 규모는 매우 커졌으며, 이로 인해 비트코인을 겨냥한 51% 공격은 일어나지 않을 것이다.
* 블록체인의 규모가 충분히 커지면 한 개인이나 그룹이 다른 모든 참여 노드들을 압도할 수 있을만큼의 컴퓨팅 파워를 보유할 가능성이 급격히 낮아지기 떄문이다.
* 이전에 승인된 블록은 모두 암호화 증명으로 연결되어 있기 때문에, 체인이 증가할수록 블록을 변경하는 것은 더욱 어려워진다.
* 블록이 더 많은 승인을 받을 수록, 해당 블록을 변경하거나 되돌리는 데는 더 많은 비용이 들 수 밖에 없다.

#### 51% 공격 사례

* 공격자가 비트코인 네트워크의 절반보다 더 많은 연산력을 가지는 것은 매우 어렵지만, 규모가 작은 암호 화폐 네트워크에서는 가능하기도 하다. 
* 비트코인과 비교했을 때, 여러 알트 코인들은 블록체인을 보호할 해시파워를 비교적 적게 가지고 있다. 
* 몇몇 알트 코인들은 실제로 51% 공격이 일어날 수 있을 만큼 적게 가지고 있기도 한다.
* 51% 공격이 발생한 암호 화폐들의 사례
* 버지(Verge)
  * 버지의 첫번째 51% 공격은 2018년 4월 '포르노 허브'와의 제휴를 발표하기 약 2주 전 발생했다. 25만 버지 코인을 탈취당했다. 
  * 두 번째 공격은 5월에 발생했으며, 3,500만 버지코인(시가 18억 원)이 넘는 피해가 있었다. 
  * 51% 공격을 진행한 해커는 익명 게시판에 거래 시간을 기록하는 장치를 조작하여 쉽게 풀 수 있는 해시 함수로 된 블록을 한꺼번에 생산한 뒤 코인을 채굴하는 식으로 공격했다.
* 모나코인(Monacoin)
  * 모나코인은 2018년 5월, 블록보류 공격(Block Withholding Attack)이라고 불리는 공격을 당했다. 
  * 이 공격으로 인해 모나코인 블록체인의 대규모의 체인 재구성이 일어났으며, 거래소는 약 1억원 정도의 금전적 피해를 입었다.
  * 모나코인 블록체인은 2018년 5월 13일부터 15일까지 빈번하게 재구성되었으며, 최대 20블록까지 재구성되기도 했다. 
  * 이에 모나코인 유저들은 다른 거래소들에게 모나코인 입금 시 컨펌 횟수를 늘리도록 연락하였으며, 각 거래소들은 입금을 정지하거나 컨펌 횟수를 늘리면서 해당 사건을 마무리했다.
* 비트코인 골드(Bitcoin Gold)
  * 비트코인 공격자는 네트워크 전체 해시파워의 51% 이상을 획득하여 블록체인을 제어했다. 
  * 비트코인 골드와 같은 작은 네트워크에서도 절반 이상의 해시 파워를 얻는 것은 비용이 많이 들어가지만, 이중 지불 공격을 병행하면 수익을 낼 수 있다. 
  * 공격자의 주소 거래 내역에는 2018년 5월 16일 이후 해당 주소로 38만8,200 BTG(한화 201억 1900만원)가 입금되었다. 
  * 이후 비트코인 골드는 더 이상의 피해를 방지하기 위해 하드 포크를 결정했다.
* 젠 캐시(ZEN Cash)
  * 2018년 6월 2일 젠캐시에 대한 블록보류 공격으로 2만 3,152개의 젠 코인(한화 약 7억원)에 대한 이중 지불 피해가 발생했다. 
  * 젠 캐시 개발팀은 공격을 인지한 후 바로 해시 난이도를 높여 추가 공격을 막았다.
* 이더리움 클래식(Ethereum Classic)
  * 2019년 1월 5일부터 약 사흘간 이더리움 클래식에서 총 11회의 이중 지불 공격이 발생했다.
  * 이로 인해 8만 8,500 ETC(한화 약 12억 3천만원)가 이중 지불 되었다. 
  * 코인베이스는 공격을 감지한 직후 이더리움 클래식을 주시하고 있다가, 세 번째 공격이 발생한 이후 이더리움 클래식의 거래를 중지시켰다. 
  * 공격 발생 후 이더리움 클래식은 컨펌 횟수를 400회까지 늘려 문제를 해결했다.

### 리플레이 공격

* 리플레이 공격(Replay Attack)이란 공격자가 보안 네트워크 통신을 가로채고, 해당 통신의 수신자로 하여금 공격자가 원하는 일을 수행하도록 하기 위해 통신을 지연시키거나 재전송하는 방식
  * 해커가 네트워크에서 메시지를 가로챈 후 메시지를 복호화하기 위한 별도의 과정이 필요하지 않다. 
  * 메시지를 포함한 통신 전체를 다시 전송하는 것으로도 공격을 성공할 수 있다.

#### 리플레이 공격 동작방식

* 앨리스가 밥에게 100 달러를 송금해달라고 요청한다고 가정한다.
1. 앨리스는 밥에게 100 달러를 송금해달라고 요청 “111-222-33으로 100달러를 보내세요" 메시지를 보낸다.
2. 밥은 앨리스를 신뢰하기 때문에 요청 메시지에 적힌 “111-222-33”(앨리스의 주소)에게 100달러를 송금한다.
3. 만약 앨리스가 요청을 보냈을 때 공격자가 앨리스의 요청을 가로채어 밥에게 메시지를 다시 보낼 수도 있다. 이 경우, 시나리오는 다음과 같이 변한다.
   1. 앨리스는 밥에게 100 달러를 송금해달라고 요청을 보낸다.
   2. 공격자는 앨리스의 요청을 가로채, 메시지 중 앨리스의 주소 대신 자신의 주소 “412-123-90”으로 바꾼다.
   3. 바꾼 메시지 "412-123-90으로 100달러를 보내세요"를 밥에게 전송한다.
   4. 밥은 앨리스로부터 왔다고 생각하는 요청 "412-123-90으로 100달러를 보내세요"를 확인하고 412-123-90으로 100달러를 송금한다.
   5. 이번에는 앨리스가 아닌 공격자에게 돈이 전달된다.

#### 암호화폐에서 리플레이 공격이 위험한 이유

* 하드포크가 진행되면, 원장 데이터는 하드 포크 이전 버전과 이후 버전으로 나누어지게 된다.
* 하드포크가 진행되어 체인이 A와 B로 나누어졌다고 가정한다. 
* 하드 포크 이후 생겨난 B 체인에서 처리한 트랜잭션은, 이론적으로 A 체인에서도 유효하게 사용할 수 있다.
* 따라서 A와 B에 모두 계정이 있는 사용자는 B에서 트랜잭션을 발생시켰을 때, A 체인에서 누군가가 해당 트랜잭션을 탈취해 브로드캐스팅하면 A 체인에서도 해당 트랜잭션이 처리된다.
* 블록체인 하드포크 시 리플레이 공격 시나리오
1. 비트코인에서 비트코인과 비트코인 캐시로 하드 포크가 일어난다.
2. 앨리스는 밥에게 100 BCH를 보낸다.
3. 밥은 악의적인 사용자이기 때문에, ‘앨리스가 밥에게 100 BCH를 보냄'이라는 트랜잭션을 비트코인 네트워크에 브로드캐스팅한다.
4. 비트코인 네트워크에서도 비트코인 캐시의 트랜잭션을 유효하게 처리할 수 있으며, 이 체인에서는 아직 트랜잭션이 처리되지 않았기 때문에 트랜잭션이 블록에 들어가 처리된다.
5. 앨리스의 지갑에서는 100 BCH만 빠져나간게 아니라, 100BTC도 빠져나가게 된다.
   1. 100 BCH를 보내는 트랜잭션이 리플레이 되어, 비트코인 체인에서도 해당 트랜잭션이 실행되어 비트코인 네트워크에서 사용하는 100 BTC을 전송한 것이기 때문이다.

#### 리플레이 공격 대안

* 세션 식별자 추가
  * 통신 당사자 간 일회용 토큰을 해싱한 값을 공유하여 리플레이 어택을 피한다.
  1. 앨리스가 밥에게 일회용 토큰을 보낸다.
  2. 밥은 토큰을 암호화하여 앨리스에게 보낸다.
  3. 앨리스는 밥과 동일한 방식으로 토큰을 암호화하고, 그 값이 밥으로부터 받은 값과 같은 경우, 통신을 진행한다.
  4. 공격자가 이 암호화된 값을 가로채고 다른 통신에서 사용하려고 해도, 앨리스가 밥에게 다른 일회용 토큰을 보내면 다른 암호화된 값이 나올 것이기 때문에 공격자가 가로챈 값은 사용할 수 없게 된다.
* 일회용 비밀번호
  * 아주 짧은 세션 시간을 가진 비밀번호를 두 통신 당사자가 공유하여, 공격자가 가로채 재사용하지 못하도록 한다.
* 타임 스탬프
  * 앨리스가 네트워크에 시간을 MAC와 함께 브로드캐스트한다.
  * 밥은 앨리스에게 통신을 요청할 때, 자신의 통신 메시지에 앨리스가 브로드캐스트한 시간을 기준으로 예상 시간을 포함시켜 인증을 진행한다. 
  * 앨리스는 타임 스탬프가 예상 시간 범위 내에 있는 메시지만 수락한다.

### 이클립스 공격

* 이클립스 공격(Eclipse Attack)은 공격자가 네트워크 상의 노드를 방해하기 위한 공격
* 정교한 공격을 준비하기 위해 네트워크에 혼란을 야기시킬 때 주로 사용한다.
* 이클립스 공격은 전체 네트워크를 공격하기 보다는 특정 노드를 격리시켜 정직한 다른 노드로부터 정보를 수신받지 못하게 여러 악의적인 공격자 노드가 네트워크를 독점한다. 
* 이 공격 노드들은 가짜 트랜잭션이 담긴 블록을 격리한 노드들에게 브로드캐스트하여 이중 지불 공격을 가능하도록 만든다.

#### 이클립스 공격 동작방식

* 블록체인에서 노드는 다른 노드들과 동시적으로 연결될 수 없다.
  * 대신 제한된 인접 노드들과 연결되어 있다. 
  * 노드들이 데이터를 공유할 때는 모두가 동시에 공유하는 것이 아니라, 하나의 노드에서 주변 노드로 점점 퍼져나가는 브로드캐스트 방식을 사용한다.
* 공격자는 공격 대상의 이웃 노드들을 자신의 노드로 구성하여, 공격 대상 노드가 가짜 트랜잭션이 담긴 블록을 받도록 한다.
* 발생할 수 있는 공격 효과
  * 엔지니어링 블록 레이스(Engineering Block Races)
    * 블록 레이스는 채굴 노드들이 가장 먼저 유효한 논스 값을 찾아 블록을 생성하는 경쟁을 의미한다.
    * 이클립스 공격에서는 이클립스 공격 대상 노드와 공격자의 노드가 동시에 블록을 생성한 경우
      * 공격 대상 노드가 생성한 블록을 숨김으로써 해당 블록은 고아 블록이 된다.
      * 자신의 블록이 네트워크에 올라갈 수 있도록 합니다.
  * 채굴 파워 분할(Splitting Mining Power)
    * 공격자가 51% 공격을 하기 위해 네트워크의 전체 채굴 파워를 쪼갤 수도 있습니다. 
    * 이러한 방식으로 공격자의 채굴 파워가 네트워크의 쪼개진 채굴 파워보다 커지게 되면 쉽게 51% 공격을 개시할 수 있다.
  * N - 컨펌 이중 지불(N-Confirmation Double Spending)
    * 일반적으로 가게 주인이 물건을 팔고 송금을 받았을 때
      * 실제로 블록이 컨펌되기 전까지는 물건을 제공하지 않는다.
      * 블록이 재배열 될 수도 있기 때문이다.
* 이클립스 공격자에 의해 여러 채굴 노드들이 공격 대상이 되어 격리된 경우
  * 공격자는 자신의 트랜잭션을 이클립스 공격 대상인 채굴 노드에게 제공하여 블록체인에 추가하도록 한다.
  * 이 노드들은 이후에도 블록을 계속 생성하면서 공격자의 트랜잭션이 든 블록이 컨펌되도록 한다.
* 이클립스 공격 대상이 된 가게 주인은 트랜잭션이 들어있는 블록이 컨펌되는 것을 보고 물건을 제공한다. 
  * 이 후, 공격자가 격리된 노드들이 만든 블록체인을 전체 네트워크에 공유하면, 해당 블록체인의 노드들은 고아 블록이 되면서 트랜잭션 자체가 취소되게 된다.

#### 이클립스 공격 대처 방법

* 무작위 노드 선택(Random Node Selection)
  * 노드가 피어를 선택할 때 무작위가 아닌 경우, 공격자가 자신 주변의 노드를 공격 대상으로 선택할 수 있게 된다. 
  * 따라서 노드가 피어를 랜덤으로 선택하게 하여 공격자가 공격 대상 노드를 정하기 어렵도록 만들 수 있다.
* 정보 저장
  * 노드가 다른 노드에 대한 정보를 기억하도록 하면, 해당 노드가 네트워크를 떠났다가 재접속 했을 때 이전에 연결했던 정직한 노드와 연결하여 정직한 피어 관계를 지속할 수 있다.
* 연결 수 늘리기
  * 하나의 노드에 연결된 피어의 갯수를 늘리면, 노드가 정직한 노드에게 연결될 가능성 역시 높아진다.

### 인적 문제로 발생할 수 있는 보안적 이슈

* 악의적인 공격자에 의해 발생할 수 있는 공격

#### 크립토재킹 공격

* Cryptojacking
* 감염된 피해자의 장치를 사용해 암호화폐를 채굴하는 것을 의미한다. 
* 공격자는 악성 채굴 프로그램을 사용하도록 유도하여, 해당 프로그램을 실행하면 악성 프로그램에 감염 되어 눈치채지 못할 만큼 시스템 자원을 이용해 채굴을 하게 된다.
* 감염된 피해자는 자신도 모르는 새에 채굴을 시작하고, 공격자는 피해자의 해시 파워를 사용해 채굴 보상을 받는다. 
* 암호화폐 채굴에는 많은 해시 파워가 필요하기 때문에 공격자들은 최대한 많은 피해자를 감염시켜, 저위험, 저비용으로 채굴을 위한 컴퓨터 자원을 모은다.
* 초창기 악성 채굴 프로그램은 악성 링크나 이메일 첨부 파일을 눌렀을 때 감염되도록 하였지만, 오늘날에는 보다 정교한 악성 채굴 프로그램이 개발되었다. 
* 랜섬웨어 등과 같이 컴퓨터 내 데이터를 손상시키지는 않는다. 
* 다만 크립토재킹은 컴퓨터로 채굴을 하기 때문에 CPU의 성능을 저하시킨다.
* 웹 기반 크립토재킹
  * 현재 대부분의 악성 채굴 프로그램은 웹 사이트 스크립트를 통해 실행된다.
  * 웹 기반 크립토재킹은 웹 사이트 내에서 실행되는 스크립트를 통해 악성 채굴 프로그램을 실행하며, 사용자가 웹 사이트에 머물러 있는 동안 브라우저를 통해 자동으로 채굴을 하도록 한다. 
  * 웹 기반 크립토재킹은 보통 모네로(Monero)를 많이 채굴한다. 
    * 모네로는 채굴을 위해 많은 해시 파워를 필요로 하지 않으며, 프라이버시와 익명성의 수준이 높아 거래를 추적하는 것이 어렵기 때문이다.
* 코인하이브
  * 코인하이브(CoinHive)는 웹 기반 크립토재킹을 최초로 구현하였다. 
  * 코인하이브는 자바스크립트로 채굴을 할 수 있도록 구성되어 있다. 
  * 코인하이브의 초창기 목적은 악성 채굴 프로그램이 아니라, 웹사이트 소유자들이 광고가 아닌 채굴을 통해 수익을 얻을 수 있도록 하는 것이었다.
  * 코인하이브는 대부분의 브라우저와 호환이 되며, 배포 역시 쉽다. 
  * 코인하이브를 사용하면 채굴 수익의 30%를 가져간다.
  * 그러나 코인하이브는 그 목적과는 다르게, 해커들이 여러 웹사이트를 해킹하여 코인하이브를 통해 웹사이트 소유자나 사용자의 허락 없이 채굴을 하도록 만들기 위해 사용되기 시작하면서 많은 비난을 받았다.
  * 오늘날 코인하이브는 보안 감지 프로그램에 의해 쉽게 확인되기 때문에 위협적이지는 않지만, 코인하이브의 배포와 적용이 쉽기 때문에 주의를 기울여야 한다.
* 더스팅 공격
  * Dusting Attack
  * 더스팅 공격은 해커들이 아주 적은 양의 코인을 사용자의 지갑에 전송하여 사용자의 신원을 파악하는 악성 공격이다.
  * 더스트
    * Dust
    * 아주 적은 양의 코인이나 토큰을 의미한다. 
    * 가령 비트코인의 가장 작은 단위는 1 사토시로, 환산하면 0.00000001BTC이다. 
    * 수백 사토시 정도를 더스트라고 부른다. 
    * 더스트는 가치 자체가 거의 없다보니, 일반적인 지갑 사용자들은 이 더스트들은 잘 신경쓰지 않는다.
  * 해커들은 일반 사용자들이 더스트 수준의 작은 금액에는 관심을 두지 않는다는 것을 악용한다. 
  * 먼저 일반 사용자들의 주소로 더스트 수준의 적은 금액을 보내 많은 주소를 "더스팅(Dusting)" 한다. 
  * 그리고 나서 해당 송금 트랜잭션과 더스팅된 지갑들의 트랜잭션을 추적한다. 
  * 이 트랜잭션을 추적하다보면, 결국 지갑을 소유한 개인이 누구인지 알수 있다.
  * 블록체인은 탈중앙화 되어있고 주소 기반이기 때문에 익명성이 보장된다. 
    * 그러나 대부분의 사람들은 거래소를 이용하며, 개인 지갑과 거래소 지갑을 연결시킨다. 
    * 따라서 거래소 지갑에 있는 사용자의 개인 정보가 개인 지갑에도 연결되게 된다. 
    * 이러한 방식으로 해커들은 익명 사용자의 개인 정보를 파악한다.
  * 2018년 10월, 비트코인 사무라이(Bitcoin Samurai) 지갑 개발자들은 일부 사용자들이 더스팅 공격을 받고 있다고 발표했다. 
  * 비트코인 사무라이는 더스팅 추적을 실시간으로 알려주는 등 사용자가 더스팅 공격을 받고 있음을 인지시켜 사용자가 의심스러운 자금을 걸러내 트랜잭션에 더스트 자금을 사용하지 않을 수 있도록 지원했다.
* 시빌 공격
  * 시빌 공격은 한 개인이 네트워크의 여러 노드를 장악하려는 악성 공격이다. 
  * 공격자는 충분한 수의 가짜 노드를 생성하여, 기존의 신뢰할 수 있는 노드를 네트워크에서 제외시킨다. 
  * 이를 통해 블록을 수신하거나 전송하는 것을 거부하거나, 다른 노드들을 네트워크에서 차단할 수도 있다. 
  * 공격자가 네트워크 전체의 해시 파워를 넘는 대규모 시빌 공격을 하는 경우에는 51% 공격도 함께 발생할 수 있다.
  * 시빌 공격에 대한 대응
    * 많은 블록체인은 다양한 합의 알고리즘을 이용해 시빌 공격을 방어한다. 
    * 그러나 합의 알고리즘은 시빌 공격을 원천적으로 봉쇄하기 보다는, 시빌 공격에 대한 비용 대비 수익보다 정상적인 채굴을 통한 비용 대비 수익을 더 크게 만들어, 시빌 공격 자체를 비효율적인 것으로 만든다.
  * 가령, 작업 증명 방식에서는 새로운 블록 형성을 위해 특정한 규칙들을 가지고 있다. 
    * 규칙 중 하나는 블록을 생성하는 능력이 작업 증명 방식 메커니즘의 전체 프로세싱 파워와 비례해야 한다는 것이다. 
      * 이는 새로운 블록을 생성하는데 필요한 컴퓨터 파워를 실제로 소유해야 함을 의미한다.
      * 공격자가 많은 비용을 지불하여 해시 파워를 올려야 하기 때문에 공격을 감행하기가 매우 어렵다.
  * 지분 증명 방식에서는 작업 증명 방식과는 다르게 물리적 자원이 아닌 경제적 자원을 사용해야 한다. 
    * 지분 증명 방식에서는 채굴을 하기 위해서는 압도적으로 많은 양의 자산을 블록체인에 스테이킹 해야 하기 때문에, 시빌 공격을 했을 시 스테이킹 된 자신의 자산을 돌려받지 못할 수도 있다.

### 구현된 블록체인에서 생길 수 있는 보안적 이슈

* 악의적인 공격자에 의한 공격 중, 몇몇 공격들은 구현된 블록체인 자체의 허점을 이용한 공격

#### DAO 사건

* The DAO
  * DAO는 블록체인 기반의 협동 조직으로, 코드로 규칙을 설정하고 실행한다. 
  * DAO는 중앙 집중식 통제 구조를 투자자-이해당사자에 의해 결정되는 기술민주적인(Techno-Democratic) 접근법으로 대체한다.
  * The DAO는 DAO 거버넌스의 초기 구현체이며, 오늘날 DEFi 플랫폼과 같은 블록체인 서비스들에 큰 영향을 미치고 있다.
  * 이더리움 프로토콜 개발자인 크리스토프 젠츠(Christoph Jentzsh)는 집단화된 이더리움 기반 투자 조직을 위한 코드를 오픈 소스로 공개하였다.
    * 이에 기반하여 The DAO는 2016년 4월 30일 이더리움으로 교환하는 방식으로 DAO 토큰을 판매하여 자금을 조달했다. 
    * 그 결과 The DAO 프로젝트에는 약 1억 5,000만 달러(한화 약 1조 7천억 원)가 넘는 자금을 성공적으로 조달했다.
    * 이는 역사상 가장 많은 금액이 모인 크라우드 펀딩이다.
* The DAO 해킹
  * 2016년 6월 17일, 악의적인 공격자가 The DAO로부터 자금을 빼낼 수 있는 허점을 발견했다. 
  * 공격 개시 후 몇시간 동안 약 30만 이더리움이 도난당했으며, 공격자는 자금을 빼돌린 이후 공격을 멈췄다.
    * 이 공격에서 공격자는 트랜잭션 이후 DAO의 스마트 컨트랙트가 잔액을 업데이트 하기 전에 이더를 반환하도록 요청을 할 수 있었다. 
      * 이 요청이 가능했던 이유에는 두 가지가 있다. 
        * 첫 번째는, DAO 스마트 컨트랙트를 만든 개발자들이 재귀적 호출 가능성을 고려하지 않고 코드를 작성했기 때문이다. 
        * 두 번째는, 스마트 컨트랙트가 송금을 할 때, 자신이 가지고 있는 자금을 송금한 후에, 컨트랙트 내 잔액을 갱신하는 순서로 구성되어 있었다는 점 때문이다. 
          * 스마트 컨트랙트 자금을 송금한 후, 잔액을 갱신하기 전에 재귀적 호출을 하게 되면, 컨트랙트는 계속 자금을 송금하기만 하고 잔액을 갱신하지 않게 된다.
  * 중요한 것은 이 버그는 이더리움 자체의 문제가 아니라, 이더리움에 기반을 둔 어플리케이션의 문제였다는 점이다. 
    * 만약 어떤 웹사이트가 제대로 동작하지 않는다고 해서 인터넷 전체에 문제가 있는 것은 아니다. 
    * 마찬가지로, The DAO에 심각한 버그가 있는 것이지, 이더리움 자체에 문제가 있는 것은 아니다. 
    * The DAO의 코드는 여러 결함을 가지고 있었으며, 재귀적 호출 문제도 그 중 하나였다. 
  * 이더리움 커뮤니티와 The DAO 팀은 손실된 토큰에 대한 악용에 대처하기 위해 여러 방법을 제시했다.
    * 자금은 약 28일간 계좌에 홀딩되어야 하기 때문에 공격자가 해당 자금을 빼돌릴 수는 없었다. 
    * 이더리움은 손실된 자금을 원래 소유자들에게 환불하기 위해 하드 포크를 단행했다. 
    * 환불을 받는 토큰 소유자에게는 DAO 토큰의 IO(Initial Offering) 당시의 비율과 동일하게, 1 이더 당 100 DAO 토큰으로 지급했다.
* The DAO 사건의 교훈
  * 현재 The DAO는 더이상 서비스되고 있지 않다. 
  * 그러나 The DAO는 DAO를 구축하는 개발자들에게 견고한 블록체인 플랫폼 구현의 중요성을 일깨워주었다.
  * The DAO 해킹은 이더리움 블록체인의 문제가 아니라, 공격자가 구현에 사용된 코드의 허점을 사용하여 이루어진 것이기 때문이다. 
  * 만약 코드가 견고하게 작성되었다면, 이러한 해킹을 피할 수 있었을 것이다.

#### 패리티 멀티시그 지갑 동결 사건

* 패리티 멀티시그 지갑이란?
  * 이더리움의 공동 설립자이자 CTO인 개빈 우드(Gavin Wood)는 이더리움 인프라를 위한 소프트웨어를 개발하는 비영리 단체인 EthCore를 설립하면서 시작했다.
  * 후에 패리티 테크놀로지(Parity Technologies)로 이름을 변경하였다.
  * 패리티
    * Parity
    * 패리티 사의 주요 소프트웨어인 패리티는 이더리움 노드 소프트웨어를 위한 웹 인터페이스를 제공하는 이더리움 클라이언트
    * 패리티에서 사용자는 일반적인 이더 및 기타 토큰 지갑 기능을 사용할 수도 있으며, 이더리움 블록체인에 구축된 스마트 컨트랙트와도 상호작용 할 수 있다. 
    * 패리티 지갑은 이더 전송을 관리하고, 모든 표준 토큰과 완벽하게 통합되도록 설계되었다.
* 패리티 멀티시그 지갑 동결
  * 멀티시그는 스마트 컨트랙트 소스코드의 형태로 사용자에게 배포된다. 
    * 누군가가 이 스마트 컨트랙트를 가지고 싶을 때는 레포지토리에서 최신 코드를 가져와 이더리움 블록체인에 해당 컨트랙트를 배포하고, 다음 소유자를 설정하고, 자금을 배치하는 방식이다. 
    * 각 지갑은 이 소스코드의 개별 인스턴스가 된다.
  * 패리티의 경우, 자금을 인출할 수 있는 인출 함수 등과 같은 스마트 컨트랙트의 필수적인 로직들은 WalletLibrary라는 이름의 라이브러리에 있다. 
    * 이 라이브러리는 패리티 멀티시그가 사용하는 스마트 컨트랙트에 기본으로 들어가있다. 
    * 라이브러리를 사용한 코드 분리는 가스 수수료를 절감하는 등의 장점도 있지만, 라이브러리에 결함이 있다면, 해당 라이브러리를 사용하는 모든 컨트랙트에 영향을 미치게 된다.
    * 2017년 11월 6일 한 공격자가 라이브러리를 지갑화하여 해당 지갑을 파괴하는 공격이 벌어졌다.
      * 이 공격으로 인해 라이브러리 그 자체를 하나의 지갑으로 초기화하는 것이 가능하고, 지갑화된 라이브러리의 소유자는 해당 지갑을 파괴할(Kill) 권한을 가지게 된다는 것이 밝혀졌다. 
      * 악의적인 공격자가 라이브러리를 지갑으로 만든후 파괴하면서, 라이브러리를 사용하는 모든 컨트랙트가 무용지물이 되어버렸다.
      * WalletLibrary가 배포된 이후 생성된 멀티시그 지갑들은 동결되었다. 
      * 이 지갑들은 총 587개이며, 총 513,774.16 ETH(오늘날 한화 약 2조 7천억 원)가 동결되었다. 
      * 이로 인해 패리티 멀티시그 지갑을 사용해 ICO 자금을 보관하던 폴카닷(Polkadot)과 같은 회사들의 자금 역시 동결되었다.