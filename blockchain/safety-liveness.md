# Safety, Liveness

* 합의 포로토콜이 만족해야 하는 속성
* safety
  * 시스템에 나쁜 일이 발생하지 않는다는 의미
  * 모든 정상적인 참여자는 같은 상태에 동의해야 한다.
  * 그 상태는 유효해야 한다.
  * 문제 없는 노드는 잘못된 합의를 하지 않는다.
* liveness
  * 시스템은 항상 살아있어야 한다.
  * 결국 어떤 상태에 동의하여야 한다.
  * 모든 참여자는 동의된 상태에 도달해야 한다.
  * 문제 없는 노드는 반드시 합의한다.

## FLP Impossibility

* 아무 문제 없는 두 노드가 서로 다른 값으로 합의하면 안 된다.
  * 다른 값을 합의했다는 것은 같은 높이에 서로 다른 블록이 생성됐다는 뜻
  * 합의 (consensus)의 safety
* 합의는 언젠가 이루어져야 한다.
* 분산 시스템에서 합의는 노드 간의 메시지를 주고받으며 각 노드의 상태를 변경시키며 이루어진다.
* 문제 없는 노드들은 무한 루프에 빠지지 않고 반드시 상태 변경이 종료돼야 한다.
* 모든 노드가 문제 없이 합의를 할 수 있으면 이 시스템은 liveness가 보장된다고 말한다.
* 문제 없는 노드 사이에선 잘못된 합의가 이루어지지 않는다는 의미
* 문제 없는 노드들은 반드시 합의를 한다.
* 문제점
  * byzantine failure가 아닌 fail-stop failure가 하나만 있어도 safety와 liveness를 둘 다 만족하는 합의 알고리즘이 존재할 수 없다.
    * flp impossibility 혹은 flp theorem
    * 합의 알고리즘을 선택한다는 것은 safety와 liveness중 무엇을 선택하고 무엇을 버릴까의 문제

## Liveness over safety

* nakamoto consensus
* 비트코인이 사용하는 합의 알고리즘
* 사토시 나카모토가 처음 제안하였다.
* 언제나 더 어려운 문제를 푼 체인이 있으면 그 체인을 유효한 체인으로 판단한다.
* 지금 있는 체인보다 더 긴 체인을 만들 해시 파워만 있으면 언제든지 현재 합의된 블록을 다른 블록으로 대체할 수 있다.
* 블록체인에서 finality(완결성)이 보장되지 않는다고 말한다.
* FLP Impossibility에서는 liveness를 위해 safety를 포기했다고 한다.
* liveness 중시 nakamoto consensus에서 출발한 합의 알고리즘은 safety 보장할 방법 추가하는 방식으로 발전했다.
  * 이더리움 casper, the friendly finality gadget 등
  * casper
    * 기존의 PoW로 Liveness 보장하며 블록을 생성한다. 
    * 50블록마다 투표하여 safety가 보장되는 지점을 만든다.
* finality
  * 완결성
  * 블록체인에 커밋되면 잘 구성된 모든 블록이 취소되지 않는다는 확인
  * 사용자는 거래할 때 거래가 완료되면 거래를 임의로 변경하거나 되돌릴 수 없다는 확신을 원한다.
    * 블록체인 합의 프로토콜을 설계할 때 최종성이 중요하다.
  * 현재 나카모토 합의 기반 시스템에서 51% 공격과 이기적 채굴은 블록 취소 가능성을 허용하여 시스템의 건강을 위협한다.
    * 악의적인 행위자가 채굴 파워의 51퍼센트를 축적할 수 있는 경우 이중 소비 공격을 할 수 있다.
  * 이런 프로토콜은 확률적 최종성을 제공하는 한편 다른 프로토콜은 절대적 최종성을 보장할 수 있다.

## Safety over liveness

* safety를 중시하는 합의 알고리즘
* 분산 시스템에서 연구되던 PBFT에 기반한 BFT계열 합의 알고리즘이 속한 부분
* cosmos에서 사용하는 tendermint가 대표적인 safety 보장하는 bft 알고리즘
* BFT 알고리즘
  * byzantine fault tolerance
  * 비잔틴 결함
  * 컴퓨터 시스템의 상태
  * 분산 컴퓨팅 구성 요소가 실패할 수 있는 시스템, 불완전한 구성 요소가 실패했는지 여부에 대한 정보
  * 다른 네트워크 모델에서 liveness가 보장됨을 증명한다.
* tendermint
  * 하나의 라운드가 propose, prevote, precommit 3개의 단게로 나누어진다.
  * prevote와 precommit스텝에서 각각 2/3+1개 이상 모아야 합의가 이루엊니다.
  * 합의에 2/3+1개 이상의 동의가 필요하기 때문에 어떤 상황에서도 서로 다른 두 블록이 동시에 생성되는 일이 없다. 
  * 전송된 메시지가 시간 안에 도달하는 것을 보장하지 못하는 비동기 네트워크에서는 합의가 이루어지지 않아 블록이 생성되지 않을 수 있다.
    * liveness는 보장되지 않는다.
  * 비동기 네트워크 모델에서는 메시지가 전송되는 것이 보장되는 기간이 없다.
    * 메시지가 무한한 시간 후에 도착하는 것도 가정해야 한다.
    * 전송한 메시지가 도착하지 않는 것을 가정해야 한다.
  * 정해진 시간 안에 메시지 전달이 보장되는 동기 네트워크 모델을 사용할 수도 없다.
    * 인터넷 규모 네트워크에서 비현실적인 가정이다.
    * 이 가정에서 liveness를 증명하는 것은 의미가 없다. 
  * partial synchronous network model 사용
    * tendermint는 정해진 시간 안에 메시지가 도달하는 것이 보장되지만 정해진 시간을 알 수 없다.
    * 정해진 시간 내에 메시지가 도착하는 것이 보장되는 모델
      * 정해진 시간이 무엇인지 노드는 알지 못한다.
      * 현실적인 모델이다.
        * 현실에서도 omission failure가 발생하지 않는 한 언젠가는 메시지가 도착한다.
    * BFT 계열 합의 알고리즘은 블록 생성을 위해 2번의 투표를 모아야 한다.
      * partial synchronous network model에선 언젠가 합의될 것이 보장된다.
      * 최악의 경우 몇 번의 라운드동안 새 블록이 생성되지 않는 경우도 있다.
      * TPS 저하를 초래한다.
      * 이 문제를 해결하기 위한 방향으로 발전한다.
        * 2018년 3월 발표 Hot-Stuff 프로토콜
          * commit-certificate 
            * validator의 투표를 포함한다.
          * CC가 없는 블록도 생성될 수 있다.
            * finality가 보장되지 않는다.
            * 뒤에 cc가 있는 블록의 finality가 보장되면 그 때 finality가 보장된다.
            * 시간당 블록 생성량을 올리기 위해 safety를 어느정도 포기한다.
  